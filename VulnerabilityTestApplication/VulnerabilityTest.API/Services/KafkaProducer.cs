using Confluent.Kafka;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace VulnerabilityTest.API.Services
{
    public sealed class KafkaProducer : IDisposable
    {
        private readonly IProducer<string, string> _producer;
        private const string Topic = "vuln.scans";
        private static readonly JsonSerializerOptions JsonOptions = new()
        {
            WriteIndented = false,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        };

        public KafkaProducer(IConfiguration configuration)
        {
           
            var bootstrapServers = configuration["Kafka:BootstrapServers"];

            if (string.IsNullOrWhiteSpace(bootstrapServers))
            {
                bootstrapServers = "localhost:29092"; 
            }

            var producerConfig = new ProducerConfig
            {
                BootstrapServers = bootstrapServers,
                Acks = Acks.All,
                EnableIdempotence = true,
                MessageTimeoutMs = 15000,
            };

            _producer = new ProducerBuilder<string, string>(producerConfig).Build();
        }

        public async Task SendStartedAsync 
            (
            string operationId,
            int userId,string userEmail, 
            string targerUrl,
            CancellationToken cancellationToken
            )
        {
            var payload = new
            {
                @event = "started",
                operationId,
                userId,
                userEmail,
                targerUrl,
                timestamp = DateTime.UtcNow
            };

            var value = JsonSerializer.Serialize(payload, JsonOptions);

            var message = new Message<string, string> 
            {
                Key = operationId, 
                Value = value ,
                Headers = new Headers
                {
                    new Header("event_type", Encoding.UTF8.GetBytes("scan.started"))
                }
            };

            try
            {
                var deliveryResult = await _producer.ProduceAsync(Topic, message, cancellationToken);

                
            }
            catch (ProduceException<string, string> ex)
            {
               message.Headers.Add("error", Encoding.UTF8.GetBytes(ex.Error.Reason));
               throw;
            }
        }

     
        public async Task SendCompletedAsync(
            string operationId,
            int userId,
            string userEmail,      
            string targetUrl,
            int scanId,
            CancellationToken ct = default)
        {
            var payload = new
            {
                @event = "completed",
                operationId,
                userId,
                userEmail,         
                targetUrl,
                scanId,            
                occurredAt = DateTimeOffset.UtcNow
            };

            var value = JsonSerializer.Serialize(payload, JsonOptions);

            var msg = new Message<string, string>
            {
                Key = operationId,
                Value = value,
                Headers = new Headers
        {
            new Header("event_type", Encoding.UTF8.GetBytes("completed"))
        }
            };

            try
            {
                var deliveryResult = await _producer.ProduceAsync(Topic, msg, ct);
              
            }
            catch (ProduceException<string, string> ex)
            {
                throw;
            }
        }

        public void Dispose()
        {

            try
            {
                _producer.Flush(TimeSpan.FromSeconds(10));
            }
            catch
            {

            }

            _producer.Dispose();
        }
    }
}

