using Confluent.Kafka;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using VulnerabilityTest.Notifier.Email;

namespace VulnerabilityTest.Notifier
{
    public class Worker : BackgroundService
    {
        private readonly IConfiguration _config;
        private readonly EmailJsSender _email;

        public Worker(ILogger<Worker> logger, IConfiguration config, EmailJsSender emailJsSender)
        {

            _config = config;
            _email = emailJsSender;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            var bootstrap = _config["Kafka:BootstrapServers"] ?? "localhost:29092";
            var topic = _config["Kafka:Topic"] ?? "vuln.scans";

            var consumerConfig = new ConsumerConfig
            {
                BootstrapServers = bootstrap,
                GroupId = "notifier",
                AutoOffsetReset = AutoOffsetReset.Earliest,
                EnableAutoCommit = true
            };

            using var consumer = new ConsumerBuilder<string, string>(consumerConfig).Build();
            consumer.Subscribe(topic);


            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    var cr = consumer.Consume(stoppingToken);

            
                    string? eventType = null;
                    foreach (var h in cr.Message.Headers)
                    {
                        if (h.Key == "event_type")
                        {
                            eventType = Encoding.UTF8.GetString(h.GetValueBytes());
                            break;
                        }
                    }

                    string? operationId = null;
                    string? userEmail = null;
                    string? targetUrl = null;
                    int? scanId = null;

                    using (var doc = JsonDocument.Parse(cr.Message.Value))
                    {
                        var root = doc.RootElement;
                        eventType ??= root.TryGetProperty("event", out var eProp) ? eProp.GetString() : null;
                        operationId = root.TryGetProperty("operationId", out var op) ? op.GetString() : null;
                        targetUrl = root.TryGetProperty("targetUrl", out var tProp) ? tProp.GetString() : null;
                        userEmail = root.TryGetProperty("userEmail", out var ue) ? ue.GetString() : null;
                        if (root.TryGetProperty("scanId", out var sProp) && sProp.TryGetInt32(out var sid)) scanId = sid;
                    }

                    if (eventType == "completed")
                    {
                        

                        if (!string.IsNullOrWhiteSpace(userEmail) && scanId is not null && !string.IsNullOrWhiteSpace(targetUrl))
                        {
                            
                                await _email.SendCompletedAsync(userEmail, operationId, scanId.Value, targetUrl!, stoppingToken);
                                
                            
                            
                        }
                       
                    }
                    
                }
                catch (ConsumeException ex) when (!stoppingToken.IsCancellationRequested)
                {
                    
                    await Task.Delay(1000, stoppingToken);
                }
                catch (OperationCanceledException) 
                {

                }
                catch (Exception ex)
                {
                    await Task.Delay(2000, stoppingToken);
                }
            }

            try {
                consumer.Close(); 
            } 
            catch
            {
             
            }
        }
    }
}


